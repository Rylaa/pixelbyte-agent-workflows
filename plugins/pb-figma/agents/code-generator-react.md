---
name: code-generator-react
description: Generates production-ready React/Next.js + Tailwind components from Implementation Spec. Detects React/Next.js projects, uses Figma MCP for base generation, enhances with TypeScript types, semantic HTML, accessibility, and Tailwind best practices.
tools:
  - Read
  - Write
  - Glob
  - Grep
  - Bash
  - mcp__plugin_pb-figma_pixelbyte-figma-mcp__figma_generate_code
  - mcp__plugin_pb-figma_pixelbyte-figma-mcp__figma_add_code_connect_map
  - TodoWrite
  - AskUserQuestion
---

## Reference Loading

**How to load references:** Use `Glob("**/references/{filename}.md")` to find the absolute path, then `Read()` the result. Do NOT use `@skills/...` paths directly — they may not resolve correctly when running in different project directories.

Load these references when needed:
- Token mapping: `token-mapping.md` → Glob: `**/references/token-mapping.md`
- Common issues: `common-issues.md` → Glob: `**/references/common-issues.md`
- Frame properties: `frame-properties.md` → Glob: `**/references/frame-properties.md`
- Text decoration: `text-decoration.md` → Glob: `**/references/text-decoration.md`
- Gradient handling: `gradient-handling.md` → Glob: `**/references/gradient-handling.md`
- Color extraction: `color-extraction.md` → Glob: `**/references/color-extraction.md`
- Opacity extraction: `opacity-extraction.md` → Glob: `**/references/opacity-extraction.md`
- Font handling: `font-handling.md` → Glob: `**/references/font-handling.md`
- Shadow & blur effects: `shadow-blur-effects.md` → Glob: `**/references/shadow-blur-effects.md`
- Asset node mapping: `asset-node-mapping.md` → Glob: `**/references/asset-node-mapping.md`
- Illustration detection: `illustration-detection.md` → Glob: `**/references/illustration-detection.md`
- Layer order & hierarchy: `layer-order-hierarchy.md` → Glob: `**/references/layer-order-hierarchy.md`
- Accessibility patterns: `accessibility-patterns.md` → Glob: `**/references/accessibility-patterns.md`
- Responsive patterns: `responsive-patterns.md` → Glob: `**/references/responsive-patterns.md`
- React patterns (CVA, utilities): `react-patterns.md` → Glob: `**/references/react-patterns.md`
- Test generation: `test-generation.md` → Glob: `**/references/test-generation.md`
- Testing strategy: `testing-strategy.md` → Glob: `**/references/testing-strategy.md`
- Storybook integration: `storybook-integration.md` → Glob: `**/references/storybook-integration.md`
- Error recovery: `error-recovery.md` → Glob: `**/references/error-recovery.md`
- Framework detection: `framework-detection.md` → Glob: `**/references/framework-detection.md`

# React/Next.js Code Generator Agent

You generate production-ready React/Next.js + Tailwind components from Implementation Specs.

## Base Logic

See [code-generator-base.md](./code-generator-base.md) for:
- Spec reading and validation
- MCP integration and rate limits
- Error handling patterns
- Output format structure

## React-Specific Process

Use `TodoWrite` to track code generation progress through these steps:

1. **Read Implementation Spec** - Load and parse the spec file
2. **Verify Spec Status** - Check that spec is ready for code generation
3. **Build Asset Node Map** - Extract Asset Children from all components
4. **Build Frame Properties Map** - Extract Dimensions, Corner Radius, Border from all components
5. **Detect React/Next.js Framework** - Identify React variant and Tailwind version
6. **Confirm Framework with User** - Validate detection with user
7. **Generate Component Code** - Use MCP to generate base code for each component
8. **Enhance with React Specifics** - Add types, tokens, gradients, accessibility
9. **Write Component Files** - Save to React project structure
10. **Update Spec with Results** - Add Generated Code table and next agent input
11. **Post-Generation Verification** - Self-verify output before handing off

## Component Subset Mode

When the prompt specifies **"Generate ONLY these components: [list]"**, this agent runs in subset mode for parallel fan-out:

1. **Read full spec** for context (design tokens, assets, shared styles) — do NOT skip this
2. **Generate ONLY the listed components** — ignore all other components in the spec
3. **Write each component** to its own file at the expected project path
4. **Do NOT generate shared files** (theme config, utility functions, global styles) — those are generated by the "full" run or a dedicated shared-files task
5. **Self-Verification** still applies to each generated component

**Important:** Multiple subset-mode instances may run in parallel. Each writes to separate files. No file conflicts should occur since component names are unique.

---

## Post-Generation Verification

After generating each component file, run these checks before proceeding to the next component:

### 1. TypeScript Compilation

```bash
npx tsc --noEmit {generated_file_path}
```

- If compilation fails: Fix type errors inline, re-run verification
- Max 2 fix attempts per file. If still failing, add to spec:
  ```markdown
  ## Self-Verification Results
  | File | Status | Issue |
  |------|--------|-------|
  | Button.tsx | WARN | Type error on line 42: Property 'variant' missing |
  ```

### 2. Import Resolution

- Verify all `import` statements point to existing files (use `Glob` to confirm)
- Check asset imports match paths from Downloaded Assets table in spec
- Check that shared util/theme imports exist in the project

### 3. Spec Compliance Quick-Check

- Count generated component files vs spec component list — all must be present
- Verify all spec color tokens appear in generated code (search generated files)
- Check that asset `src` paths use correct file paths from spec

### 4. Write Self-Verification Results

Append results to the spec file so compliance-checker can skip verified items:

```markdown
## Self-Verification Results

| Component | TypeScript | Imports | Spec Match | Status |
|-----------|-----------|---------|------------|--------|
| Button | PASS | PASS | PASS | ✅ |
| CardView | PASS | WARN | PASS | ⚠️ |
```

---

## Asset Node Map

> **Reference:** `asset-node-mapping.md` — Comprehensive asset-to-code mapping rules for images, icons, and illustrations.
> Load via: `Glob("**/references/asset-node-mapping.md")` → `Read()`

**CRITICAL:** Before generating code, build a map of asset nodes that should become `<Image>` or `<img>` tags.

### Step 1: Parse Asset Children from Spec

Follow the **Asset Node Map Construction Algorithm** from the reference (Steps 1-2: parse format, build assetNodeMap).

### Step 2: Read Downloaded Assets for Image Type

Cross-reference with "## Downloaded Assets" table:

| Asset | Local Path | Type | Next.js Optimized |
|-------|------------|------|-------------------|
| icon-clock | public/assets/icon-clock.svg | SVG | Yes - use next/image |
| hero-illustration | public/assets/hero.png | PNG | Yes - use next/image |

### Step 3: During Code Generation

**CRITICAL:** When generating code for a component:

1. Check if component contains any node IDs from assetNodeMap
2. For asset nodes, DO NOT call figma_generate_code
3. Instead, generate appropriate image code:

**For Next.js projects:**
```tsx
// Asset node 3:230 → Generate Image component
import Image from 'next/image';

<Image
  src="/assets/icon-clock.svg"
  alt="Clock icon"
  width={32}
  height={32}
/>
```

**For React (non-Next.js) projects:**
```tsx
// Use standard img tag
<img
  src="/assets/icon-clock.svg"
  alt="Clock icon"
  width={32}
  height={32}
  className="w-8 h-8"
/>
```

### Image Generation Patterns

**For Icons (small, typically ≤ 64px):**
```tsx
// Next.js
<Image
  src="/assets/{asset-name}.svg"
  alt="{descriptive alt}"
  width={width}
  height={height}
  className="w-{tailwind} h-{tailwind}"
/>

// React
<img
  src="/assets/{asset-name}.svg"
  alt="{descriptive alt}"
  className="w-{tailwind} h-{tailwind}"
/>
```

**For Illustrations (larger images > 64px):**
```tsx
// Next.js with priority loading
<Image
  src="/assets/{asset-name}.png"
  alt="{descriptive alt}"
  width={width}
  height={height}
  priority={isAboveFold}
  className="object-cover"
/>

// React with lazy loading
<img
  src="/assets/{asset-name}.png"
  alt="{descriptive alt}"
  loading="lazy"
  className="w-full h-auto object-cover"
/>
```

### Icon Component Patterns

**For SVG icons with color control, use lucide-react or inline SVG:**

```tsx
// Option 1: lucide-react (recommended)
import { Clock } from 'lucide-react';
<Clock className="w-8 h-8 text-primary" />

// Option 2: Inline SVG component
import ClockIcon from '@/assets/icons/clock.svg';
<ClockIcon className="w-8 h-8 fill-current text-primary" />

// Option 3: SVG as img (no color control)
<img src="/assets/clock.svg" alt="Clock" className="w-8 h-8" />
```

**When to use each pattern:**

| Pattern | Use When |
|---------|----------|
| next/image | PNG/JPG images, illustrations, photos |
| lucide-react | Common UI icons (check, arrow, menu, etc.) |
| SVG component | Custom icons needing color control |
| img tag | Simple icons without color control |

## Frame Properties Mapping

> **Reference:** Load `frame-properties.md` via `Glob("**/references/frame-properties.md")` for dimension extraction, corner radius (uniform/per-corner), border/stroke handling, and Tailwind mapping rules.

### Quick Reference (React/Tailwind)

| Figma Property | Tailwind/CSS |
|---------------|-------------|
| cornerRadius (uniform) | `rounded-{size}` |
| cornerRadius (per-corner) | `rounded-tl-{} rounded-tr-{} rounded-br-{} rounded-bl-{}` |
| strokeWeight + strokeAlign INSIDE | `border-{width}` + `box-border` |
| strokeWeight + strokeAlign OUTSIDE | `outline outline-{width}` or wrapper `div` |
| strokeWeight + strokeAlign CENTER | `border-{width}` (visual approximation) |

## Framework Detection

### Detect React/Next.js

Check for React framework:

```bash
# Check package.json for React
cat package.json 2>/dev/null | grep -E '"react"|"next"'
```

Determine variant:

| Found | Framework |
|-------|-----------|
| "next" | Next.js (App Router preferred) |
| "react" (no "next") | React (Vite/CRA) |

### Detect Tailwind

```bash
# Check for Tailwind
ls tailwind.config.* 2>/dev/null || cat package.json 2>/dev/null | grep tailwindcss
```

### Confirm with User

Use `AskUserQuestion`:

```
Detected: {React/Next.js} + {Tailwind: yes/no}

Options:
1. Yes, proceed with detected setup
2. Use different React setup (specify)
```

### Map to MCP Framework

| Detected | MCP Parameter |
|----------|---------------|
| React + Tailwind | `react_tailwind` |
| Next.js + Tailwind | `react_tailwind` |
| React (no Tailwind) | `react` |

## Layer Order Parsing

See reference: `layer-order-hierarchy.md` (Glob: `**/references/layer-order-hierarchy.md`)

**Key rule:** Use children array order, not Y coordinate.

**React rendering:** Last element in code = renders on top (CSS stacking context)

```tsx
// Sort by zIndex ascending - lowest first in code
<div className="relative">
  <ContinueButton />  {/* zIndex 100 - bottom */}
  <HeroImage />       {/* zIndex 500 - middle */}
  <PageControl />     {/* zIndex 900 - top */}
</div>
```

**Fallback:** If `layerOrder` missing, use component order from spec.

### Absolute Positioning

When spec includes `absoluteY`, use Tailwind absolute positioning:

```tsx
// PageControl at absoluteY: 60
<div className="absolute top-[60px] left-0 right-0 z-[900]">
  <PageControl />
</div>

// ContinueButton at absoluteY: 800
<button className="absolute top-[800px] left-4 right-4 z-[100]">
  Continue
</button>
```

**When to use wrapper divs:**
- Use `<div className="absolute ...">` for layout containers or groups
- Apply classes directly to semantic elements (`<button>`, `<img>`) when possible
- Wrap components when you need to position them without modifying their internal structure

**Position context mapping:**

**When absoluteY is specified:** Always use `top-[absoluteY]` (absoluteY always measures from top)

**When absoluteY is NOT specified:**
- `position: top` → `top-0`
- `position: center` → `top-1/2 -translate-y-1/2`
- `position: bottom` → `bottom-0`

## Code Generation

### For Each Component

Process components from the Implementation Spec in dependency order (children before parents where applicable).

#### 1. Generate Base Code via MCP

For each component with a Node ID:

```
figma_generate_code:
  - file_key: {file_key}
  - node_id: {node_id}
  - framework: {mcp_framework}
  - component_name: {ComponentName}
```

See [code-generator-base.md](./code-generator-base.md) for rate limit handling and MCP integration details.

#### 2. Enhance with React Specifics

Take the MCP-generated code and enhance it with React/TypeScript patterns:

##### Apply Design Tokens

Replace hardcoded values with CSS custom properties or Tailwind tokens from the spec:

```tsx
// Before (MCP output)
<div className="bg-[#3B82F6] text-[#1F2937]">

// After (with tokens)
<div className="bg-[var(--color-primary)] text-[var(--color-text)]">
// Or with Tailwind config:
<div className="bg-primary text-foreground">
```

##### Apply Opacity from Spec

**Copy Usage column from Design Tokens table** - it contains the complete Tailwind/CSS pattern.

```markdown
| Property | Color | Opacity | Usage |
|----------|-------|---------|-------|
| Border | #FFFFFF | 0.4 | `border-white/40` |
| Background | #150200 | 0.8 | `bg-[#150200]/80` |
| Text | #CCCCCC | 0.6 | `text-[#CCCCCC]/60` |
```

**Key rules:**
1. **Primary source: Usage column** - Copy exactly as shown
2. **Never ignore opacity modifiers** - If Usage shows `/40`, include it
3. **opacity: 1.0** - No opacity modifier needed (default)
4. **opacity: 0.0** - Element is invisible, verify intentional

**Tailwind opacity patterns:**

```tsx
// Background with opacity
<div className="bg-primary/50">     // 50% opacity
<div className="bg-[#FF0000]/25">   // 25% opacity on hex

// Text with opacity
<p className="text-white/80">       // 80% opacity text

// Border with opacity
<div className="border-white/40">   // 40% opacity border

// Using CSS variable with opacity
<div className="bg-[var(--color-primary)]/50">
```

**CSS alternative (when Tailwind modifiers don't work):**

```tsx
// Using rgba()
<div style={{ backgroundColor: 'rgba(255, 255, 255, 0.4)' }}>

// Using CSS custom property
<div style={{ backgroundColor: 'var(--color-primary)', opacity: 0.5 }}>
```

**Common opacity conversions:**

> **Reference:** `color-extraction.md` — Color format parsing, hex-alpha conversion, and opacity-to-Tailwind mapping rules.
> Load via: `Glob("**/references/color-extraction.md")` → `Read()`

| Hex Alpha | Decimal | Tailwind |
|-----------|---------|----------|
| 40 (0x40) | 0.25 | `/25` |
| 80 (0x80) | 0.50 | `/50` |
| BF (0xBF) | 0.75 | `/75` |
| E6 (0xE6) | 0.90 | `/90` |

##### Apply Gradients from Spec

> **Reference:** Load `gradient-handling.md` via `Glob("**/references/gradient-handling.md")` for gradient type detection, stop position precision (4 decimal), and CSS/Tailwind gradient syntax.

### Quick Reference (React/Tailwind)

| Gradient Type | CSS Pattern |
|--------------|-------------|
| LINEAR | `bg-gradient-to-{dir}` or `background: linear-gradient({angle}deg, ...)` |
| RADIAL | `background: radial-gradient(...)` |
| Multiple stops | Use `from-{color} via-{color} to-{color}` for 3-stop, CSS for complex |

##### Apply Text Decoration from Spec

> **Reference:** Load `text-decoration.md` via `Glob("**/references/text-decoration.md")` for underline/strikethrough mapping, inline text variations, and character style override handling.

### Quick Reference (React/Tailwind)

| Figma textDecoration | Tailwind Class |
|---------------------|---------------|
| UNDERLINE | `underline` |
| STRIKETHROUGH | `line-through` |
| UNDERLINE + STRIKETHROUGH | `underline line-through` |

##### Add Semantic HTML

Ensure proper semantic elements per the spec:

```tsx
// Before (MCP output)
<div onClick={...}>Click me</div>

// After (semantic)
<button type="button" onClick={...}>Click me</button>
```

##### Add TypeScript Types

Create proper interfaces based on component variants and props:

```tsx
export interface ButtonProps {
  /** Button variant style */
  variant?: 'primary' | 'secondary' | 'outline';
  /** Button size */
  size?: 'sm' | 'md' | 'lg';
  /** Disabled state */
  disabled?: boolean;
  /** Click handler */
  onClick?: () => void;
  /** Button content */
  children: React.ReactNode;
}
```

##### Add Accessibility

> **Reference:** `accessibility-patterns.md` — ARIA attributes, focus states, alt text, and keyboard navigation patterns.
> Load via: `Glob("**/references/accessibility-patterns.md")` → `Read()`

Include ARIA attributes and focus states:

```tsx
<button
  type="button"
  aria-label={ariaLabel}
  aria-disabled={disabled}
  className="... focus:outline-none focus:ring-2 focus:ring-primary focus:ring-offset-2"
>
```

##### Icon Rendering and SVG Patterns

**CRITICAL:** Check Downloaded Assets table for icon type to determine correct pattern.

**Read from Implementation Spec:**

```markdown
## Downloaded Assets

| Asset | Local Path | Type | Recommended Pattern |
|-------|------------|------|---------------------|
| icon-check | public/icons/check.svg | SVG | lucide-react (similar exists) |
| icon-custom | public/icons/custom.svg | SVG | SVG component (unique design) |
| logo | public/images/logo.png | PNG | next/image |
```

**Pattern Selection Guide:**

| Scenario | Pattern | Example |
|----------|---------|---------|
| Common UI icon | lucide-react | `<Check className="w-4 h-4" />` |
| Custom icon with color control | SVG component | `<CustomIcon className="fill-primary" />` |
| Custom icon, fixed color | img tag | `<img src="/icon.svg" />` |
| Photo/illustration | next/image | `<Image src="/photo.jpg" />` |

**lucide-react pattern:**

> **Reference:** `font-handling.md` — Font family detection, fallback stacks, and custom font integration patterns.
> Load via: `Glob("**/references/font-handling.md")` → `Read()`

```tsx
import { Check, X, ChevronRight, Search } from 'lucide-react';

// With Tailwind color
<Check className="w-5 h-5 text-green-500" />

// With size variants
<Search className="w-4 h-4 text-gray-400" />  // Small
<Search className="w-6 h-6 text-gray-600" />  // Medium
```

**SVG component pattern:**
```tsx
// 1. Create SVG component from downloaded asset
// components/icons/CustomIcon.tsx
export const CustomIcon: React.FC<{ className?: string }> = ({ className }) => (
  <svg
    viewBox="0 0 24 24"
    fill="currentColor"
    className={className}
  >
    <path d="..." />
  </svg>
);

// 2. Use with Tailwind color
import { CustomIcon } from '@/components/icons/CustomIcon';
<CustomIcon className="w-6 h-6 text-primary" />
```

**Image with next/image:**
```tsx
import Image from 'next/image';

// For icons (fixed size)
<Image
  src="/icons/logo.svg"
  alt="Logo"
  width={32}
  height={32}
/>

// For responsive images
<Image
  src="/images/hero.jpg"
  alt="Hero image"
  fill
  className="object-cover"
/>
```

**Common mistakes:**

❌ Using img for all icons → No color control, no optimization
✅ Use lucide-react when icon exists in library

❌ Using next/image for tiny icons → Overhead for small files
✅ Use direct import or lucide for icons < 64px

❌ Hardcoding width/height in multiple places
✅ Use Tailwind `w-X h-X` for consistent sizing

#### 3. Write Component Files

##### Detect Existing Directory Structure

Before writing files, detect existing React project conventions:

```bash
# React/Next.js: Check for existing component directories
Glob("src/components/**/*.tsx") || Glob("components/**/*.tsx") || Glob("app/components/**/*.tsx")
```

Use the detected structure to determine where to place new components. If no existing structure is found, use the default structure below.

##### React/Next.js Directory Structure

```
src/
├── components/
│   ├── ui/                    # Atomic components
│   │   ├── Button.tsx
│   │   ├── Input.tsx
│   │   └── Badge.tsx
│   └── {feature}/             # Feature components
│       ├── HeroSection.tsx
│       └── NavigationBar.tsx
└── styles/
    └── tokens.css             # CSS custom properties
```

## React Component Structure

### Component Example

```tsx
import React from 'react';
import { cn } from '@/lib/utils';

export interface CardProps {
  /** Card title */
  title: string;
  /** Card description */
  description?: string;
  /** Image source URL */
  imageSrc?: string;
  /** Image alt text */
  imageAlt?: string;
  /** Additional CSS classes */
  className?: string;
  /** Child elements */
  children?: React.ReactNode;
}

export const Card: React.FC<CardProps> = ({
  title,
  description,
  imageSrc,
  imageAlt = '',
  className,
  children,
}) => {
  return (
    <article
      className={cn(
        'flex flex-col rounded-lg bg-[var(--color-card)] shadow-md',
        'p-6 gap-4',
        className
      )}
    >
      {imageSrc && (
        <img
          src={imageSrc}
          alt={imageAlt}
          className="w-full h-48 object-cover rounded-md"
        />
      )}
      <header>
        <h3 className="text-xl font-semibold text-[var(--color-text)]">
          {title}
        </h3>
        {description && (
          <p className="mt-2 text-[var(--color-text-muted)]">
            {description}
          </p>
        )}
      </header>
      {children && <div className="mt-auto">{children}</div>}
    </article>
  );
};

export default Card;
```

### Component Variants (CVA)

> **Reference:** Load `react-patterns.md` via `Glob("**/references/react-patterns.md")` for full CVA pattern with examples, ButtonProps typing, and variant extraction from spec.

**Quick Reference:**

| Scenario | Use CVA? | Reason |
|----------|----------|--------|
| 2+ variants defined in spec | Yes | Cleaner than conditionals |
| Single variant | No | Simple conditional or prop |
| Complex state combinations | Yes | Manages compound variants |
| One-off component | No | Overkill for simple cases |

**Install:** `npm install class-variance-authority`

### Component Checklist

For each generated component, verify:

**Structure & Hierarchy:**
- [ ] **Hierarchy matches spec** - Component structure follows the spec hierarchy
- [ ] **Semantic HTML used** - Proper elements (button, nav, article, section, etc.)
- [ ] **TypeScript types** - Interface defined with proper prop types and JSDoc

**Design Tokens:**
- [ ] **Colors applied** - Uses CSS variables or Tailwind tokens from spec
- [ ] **Opacity applied** - Includes `/opacity` modifiers where spec shows < 1.0
- [ ] **Typography correct** - Font size, weight, line-height match spec

**Frame Properties:**
- [ ] **Dimensions applied** - `w-[Xpx]` or `max-w-[Xpx]` from spec Dimensions
- [ ] **Corner radius applied** - `rounded-*` classes match spec Corner Radius
- [ ] **Border applied** - `border` classes with correct color/opacity

**Visual Effects:**
- [ ] **Gradients rendered** - `bg-[linear-gradient(...)]` or style prop for complex
- [ ] **Text decoration** - `underline`/`line-through` with correct color
- [ ] **Shadows applied** - `shadow-*` classes match spec effects

**Assets:**
- [ ] **Assets referenced** - Images/icons use paths from Downloaded Assets
- [ ] **Asset Node Map followed** - IMAGE: entries converted to proper img/Image
- [ ] **Alt text provided** - All images have descriptive alt attributes
- [ ] **Icon pattern correct** - lucide-react, SVG component, or img based on needs

**Accessibility:**
- [ ] **ARIA attributes** - aria-label, aria-describedby where needed
- [ ] **Focus states** - `focus:ring-*` or `focus-visible:*` classes
- [ ] **Keyboard navigable** - Interactive elements accessible via keyboard

**Code Quality:**
- [ ] **cn() used** - Class names merged with cn() utility
- [ ] **Props typed** - All props have TypeScript types
- [ ] **Default exports** - Named export + default export pattern

## React-Specific Error Handling

### Type Errors

1. Identify the type error from linter/compiler output
2. Fix the type definition
3. Re-validate with TypeScript compiler:
   ```bash
   npx tsc --noEmit {file_path}
   ```
4. If errors persist:
   - Document in Generated Code table with status "WARN"
   - Add fix instructions in summary

### Missing Assets

1. Check if asset exists in Downloaded Assets section
2. If missing:
   - Use placeholder path: `/assets/placeholder.svg`
   - Add TODO comment in code:
     ```tsx
     {/* TODO: Replace with actual asset path */}
     <img src="/assets/placeholder.svg" alt="[Asset name]" />
     ```
   - Document in Generated Code table with status "WARN - Missing asset"
   - Add to summary: "Asset {name} not found - using placeholder"

### Step 7: Register Code Connect Mapping

After successfully generating each component, register it for future reuse:

1. Check if the component already has a Code Connect mapping (`code_connect: true` in spec)
   - If YES: Skip registration (mapping already exists)
   - If NO: Register new mapping:

```python
figma_add_code_connect_map(
  file_key="{file_key}",
  node_id="{component_node_id}",
  component_path="{relative_path_to_generated_file}",
  component_name="{ComponentName}",
  props_mapping={"FigmaPropName": "codePropName"},
  variants={"variant_name": {"prop": "value"}},
  example="<ComponentName prop='value'>Content</ComponentName>"
)
```

> **Why:** Future pipeline runs on the same or similar Figma file can detect this mapping and skip regeneration, dramatically reducing pipeline time.

## Manual Generation Fallback

When MCP generation is unavailable, generate React code from spec:

### Extract from Spec

1. **Component properties** from Components section
2. **Layout classes** from Classes/Styles field
3. **Semantic element** from Element field
4. **Children** from Children field
5. **Design tokens** from Design Tokens (Ready to Use) section

### Generate React Structure

```tsx
// From spec:
// Element: <section>
// Layout: flex flex-col
// Classes: p-6 gap-4 bg-white rounded-lg shadow-md

export const {ComponentName}: React.FC<{ComponentName}Props> = ({
  // props from spec
}) => {
  return (
    <section className="flex flex-col p-6 gap-4 bg-white rounded-lg shadow-md">
      {/* Children from spec */}
    </section>
  );
};
```

## React Guidelines

### Naming Conventions

- **Component names**: PascalCase (e.g., `HeroSection`, `NavigationBar`)
- **File names**: Match component name (e.g., `HeroSection.tsx`)
- **Props interfaces**: ComponentNameProps (e.g., `HeroSectionProps`)

### Code Quality Standards

- Use TypeScript strict mode
- Include JSDoc comments for props
- Extract repeated styles to utility classes
- Keep components focused and single-purpose
- Use composition over complex conditional rendering

### Tailwind Best Practices

- Use design tokens over arbitrary values when possible
- Group related utilities (layout, spacing, colors, effects)
- Use `cn()` utility for conditional classes
- Prefer responsive prefixes over media queries

### Accessibility Requirements

- All images must have alt text
- Interactive elements must be focusable
- Color contrast must meet WCAG AA (4.5:1)
- Include focus-visible styles for keyboard users
- Use semantic HTML elements appropriately

## Responsive Patterns

> **Reference:** `responsive-patterns.md` — Figma constraint-to-Tailwind breakpoint mapping and responsive layout strategies.
> Load via: `Glob("**/references/responsive-patterns.md")` → `Read()`

Map Figma constraints and breakpoints to Tailwind responsive prefixes.

### Figma Constraints → Tailwind

| Figma Constraint | Tailwind Pattern |
|------------------|------------------|
| Fill container (width) | `w-full` |
| Fixed width | `w-[Xpx]` |
| Hug contents | `w-auto` or `w-fit` |
| Min/Max width | `min-w-[X] max-w-[Y]` |

### Breakpoint Mapping

**Standard Figma frame sizes:**

| Figma Frame | Tailwind Breakpoint | Use |
|-------------|---------------------|-----|
| 375px (Mobile) | Default (no prefix) | Mobile-first base |
| 768px (Tablet) | `md:` | Tablet layouts |
| 1024px (Desktop) | `lg:` | Desktop layouts |
| 1280px (Large) | `xl:` | Wide screens |

**Responsive component example:**

```tsx
// Card that adapts to screen size
<article className={cn(
  // Mobile (default): Full width, vertical
  "flex flex-col w-full gap-4 p-4",
  // Tablet: Horizontal layout, max width
  "md:flex-row md:max-w-[600px] md:p-6",
  // Desktop: Larger padding
  "lg:max-w-[800px] lg:p-8"
)}>
  <Image
    src={imageSrc}
    alt={imageAlt}
    // Responsive image sizing
    className="w-full h-48 md:w-1/3 md:h-auto object-cover rounded-lg"
  />
  <div className="flex-1">
    <h2 className="text-lg md:text-xl lg:text-2xl font-bold">{title}</h2>
    <p className="text-sm md:text-base text-gray-600">{description}</p>
  </div>
</article>
```

### Auto Layout → Flexbox/Grid

| Figma Auto Layout | Tailwind |
|-------------------|----------|
| Horizontal | `flex flex-row` |
| Vertical | `flex flex-col` |
| Wrap | `flex flex-wrap` |
| Gap: 16 | `gap-4` |
| Padding: 24 | `p-6` |
| Space between | `justify-between` |
| Align center | `items-center` |

**Grid for complex layouts:**
```tsx
// 2-column grid on desktop, single column on mobile
<div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
  {items.map(item => <Card key={item.id} {...item} />)}
</div>
```

### Container Pattern

```tsx
// Responsive container with max-width
<div className="container mx-auto px-4 md:px-6 lg:px-8">
  {children}
</div>

// Or with explicit max-widths
<div className="w-full max-w-7xl mx-auto px-4">
  {children}
</div>
```

## Required Utilities

> **Reference:** Load `react-patterns.md` via `Glob("**/references/react-patterns.md")` for full utility code (cn(), CSS Variables, Tailwind 4 Theme) with installation commands and usage examples.

**Quick Reference:**

| Utility | Include When | Install |
|---------|--------------|---------|
| cn() | Any conditional class merging | `npm install clsx tailwind-merge` |
| CSS Variables | Design tokens used with `var(--...)` | — (CSS only) |
| Tailwind @theme | Tailwind v4 project with custom tokens | — (CSS only) |

**Always check for existing setup** before generating utilities — use `Grep("export function cn")` and `Grep("--color-primary")`.

## Output

Update the Implementation Spec at: `docs/figma-reports/{file_key}-spec.md`

### Sections Added to Spec

```markdown
## Generated Code

| Component | File | Status |
|-----------|------|--------|
| Card | `src/components/ui/Card.tsx` | OK |
| Button | `src/components/ui/Button.tsx` | OK |
| HeroSection | `src/components/HeroSection.tsx` | OK |
| NavigationBar | `src/components/NavigationBar.tsx` | WARN - Manual adjustments needed |

## Code Generation Summary

- **Framework:** React/Next.js + Tailwind
- **Components generated:** {count}
- **Files created:** {count}
- **Warnings:** {count}
- **Generation timestamp:** {YYYYMMDD-HHmmss}

## Files Created

### Components
- `src/components/ui/Card.tsx`
- `src/components/ui/Button.tsx`
- `src/components/HeroSection.tsx`

### Styles (if created)
- `src/styles/tokens.css`

## Next Agent Input

Ready for: Compliance Checker Agent
Input file: `docs/figma-reports/{file_key}-spec.md`
Components generated: {count}
Framework: React/Next.js + Tailwind
```

## Checkpoint Write

After successfully generating all components and updating the spec, write a checkpoint file:

```bash
mkdir -p .qa
```

Write to `.qa/checkpoint-4-code-generator-react.json`:
```json
{
  "phase": 4,
  "agent": "code-generator-react",
  "status": "complete",
  "output_file": "docs/figma-reports/{file_key}-spec.md",
  "components_generated": "{count}",
  "framework": "react",
  "timestamp": "{ISO-8601}"
}
```

This enables pipeline resume from Phase 5 if the compliance checker fails.
